[
  {
    "objectID": "API Connection Walkthrough.html",
    "href": "API Connection Walkthrough.html",
    "title": "Strava API Connnection Walkthrough",
    "section": "",
    "text": "Code\n#Install and load the required packages if not already installed:\n\nif (!require(pacman)) install.packages(\"pacman\")\n\n\nLoading required package: pacman\n\n\nCode\n  p_load(tidyverse,DiagrammeR,networkD3,gt,httr2,jsonlite,conflicted,httpuv)\n  \n#Conflicted package set to prefer dplyr over others:\n  conflicted::conflicts_prefer(dplyr::filter)\n\n\n[conflicted] Will prefer dplyr::filter over any other package.\n\n\nCode\n  conflicted::conflicts_prefer(dplyr::data_frame)\n\n\n[conflicted] Will prefer dplyr::data_frame over any other package."
  },
  {
    "objectID": "API Connection Walkthrough.html#libraries",
    "href": "API Connection Walkthrough.html#libraries",
    "title": "Strava API Connnection Walkthrough",
    "section": "",
    "text": "Code\n#Install and load the required packages if not already installed:\n\nif (!require(pacman)) install.packages(\"pacman\")\n\n\nLoading required package: pacman\n\n\nCode\n  p_load(tidyverse,DiagrammeR,networkD3,gt,httr2,jsonlite,conflicted,httpuv)\n  \n#Conflicted package set to prefer dplyr over others:\n  conflicted::conflicts_prefer(dplyr::filter)\n\n\n[conflicted] Will prefer dplyr::filter over any other package.\n\n\nCode\n  conflicted::conflicts_prefer(dplyr::data_frame)\n\n\n[conflicted] Will prefer dplyr::data_frame over any other package."
  },
  {
    "objectID": "API Connection Walkthrough.html#api-connection-steps-overview",
    "href": "API Connection Walkthrough.html#api-connection-steps-overview",
    "title": "Strava API Connnection Walkthrough",
    "section": "API Connection steps | Overview",
    "text": "API Connection steps | Overview\n\nDisclaimer\nThis document serves as a walk through for connecting to API’s through R using the httr2 package. In this instance I will be attempting to connect to Strava’s API. I do not own this information (aside from my personal Strava data) and this is simply a collection of notes to aid in my own learning process. I am aware of the package rStrava and I drew from their package for inspiration here. I explicitly used their ratelimit function below and I have properly credited them for that. My secondary goal with this document is to familiarize myself with httr2 which is why I have not opted to use existing packages, and instead experiment with this package.\n\n\nDocs\n\nRead the documentation - Strava API V3 Documentation\nThis walk through is intended to summarize what I have learned and make the pain points more digestible. However, I cannot cover everything, with that in mind reading the documentation is still the best way to familiarize yourself with this process.\n\n\n\nOAuth2.0\n\nAuthentication - Strava uses OAuth 2.0 as its method of authentication. Below is how I break this down in my mind:\n\nOAuth is an authorization framework that allows third party applications to access data on behalf of a user. These are the parties involved in this transaction:\n\nResource Owner: The entity that owns the resource and is capable of granting access to it. Typically, this is the end-user.\nClient: The application requesting access to the resource on behalf of the resource owner. This is often a third-party application.\nAuthorization Server: The server that authenticates the resource owner and issues access tokens after getting proper authorization.\nResource Server: The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens\n\n\n\n\nAuthorization flowchart\n\nClient credentials flow - I believe that Strava is using this type of authorization. Their docs state they allow external apps to request user data, and users can grant and revoke API access on a “per-application” basis. With this method authentication is done using a client ID and secret. The returned access token grants the client access to specific, predefined scopes.\n\nAccess Token: A token that represents the authorization granted to the client.\n\n\n\nCode\n#|format: html\n#|code-fold: true\n#|label: OAuth-flowchart\n#|fig-cap-location: top\n#|fig-cap: OAuth visualization\n\nnode_ht &lt;-  2\nnode_w &lt;-  1\n\nDiagram &lt;- create_graph(directed = FALSE,\n                        attr_theme = \"lr\") %&gt;% #theme is set \"Left to Right\"\n\n# add_node() & node_aes() are all geared \n# toward formatting node attributes: color, height, shape etc. ----\n\n  add_node(\n    node_aes = node_aes(\n      shape = \"rectangle\",\n      color = \"steelblue\",\n      fillcolor = \"#007AC1\",\n      fontcolor = \"White\",\n      width = 2,\n      height = 5,\n    ),\n    type = \"B\",\n    label = \"Application\\n(Client)\\n(My Strava App)\") %&gt;%\n  add_node(\n    node_aes = node_aes(\n      shape = \"rectangle\",\n      color = \"steelblue\",\n      fillcolor = \"#FDBB30\",\n      fontcolor = \"White\",\n      width = node_w,\n      height = node_ht,\n      x = 5\n    ),\n    type = \"A\",\n    label = \"User\\n(My Strava\\nProfile)\") %&gt;%\n  add_node(\n    node_aes = node_aes(\n      shape = \"rectangle\",\n      color = \"steelblue\",\n      fillcolor = \"mediumvioletred\",\n      fontcolor = \"White\",\n      width = node_w,\n      height = node_ht,\n    ),\n    type = \"A\",\n    label = \"Authorization\\nServer\") %&gt;%\n  add_node(\n    node_aes = node_aes(\n      shape = \"rectangle\",\n      color = \"steelblue\",\n      fillcolor = \"Orangered\",\n      fontcolor = \"White\",\n      width = node_w,\n      height = node_ht,\n    ),\n    type = \"A\",\n    label = \"Resource\\n Server\") %&gt;%\n\n# Edge creation and formatting - \"edges\" are the arrows that connect our nodes.\n# Edges show the flow of info through our charts. Due to the exchange in our data we will see 6 edges:\n\n  add_edge(from = 1, to = 2,edge_aes = edge_aes(\n    label = \"1.)Authorization is requested from the\\n app to the user/profile/data owner.\",\n    fontsize = 12,\n    penwidth = 5,\n    color = \"Orange\",\n    arrowsize = .5,\n    tailport = \"n\",\n    headport = \"n\",\n    dir = \"forward\"\n  )) %&gt;%\n  add_edge(from = 2, to = 1,edge_aes = edge_aes(\n    label = \"2.)User grants authorization to the app.\",\n    fontsize = 12,\n    penwidth = 5,\n    color = \"Orange\",\n    arrowsize = .5,\n    dir = \"forward\"\n  )) %&gt;%\n    add_edge(from = 1, to = 3,edge_aes = edge_aes(\n    label = \"3.)App sends the authorization grant\\nto the authorization server\",\n    fontsize = 12,\n    penwidth = 5,\n    color = \"Orange\",\n    arrowsize = .5,\n    headport = \"n\",\n    dir = \"forward\"\n  )) %&gt;% \n    add_edge(from = 3, to = 1,edge_aes = edge_aes(\n    label = \"4.)Access token is granted to the app.\",\n    fontsize = 12,\n    penwidth = 5,\n    color = \"Orange\",\n    arrowsize = .5,\n    tailport = \"w\",\n    dir = \"forward\"\n  )) %&gt;% \n   add_edge(from = 1, to = 4,edge_aes = edge_aes(\n    label = \"5.)Access token is sent from app\\nvia HTTP|GET request.\",\n    fontsize = 12,\n    penwidth = 5,\n    color = \"Orange\",\n    arrowsize = .5,\n    dir = \"forward\",\n    headport = \"w\"\n  )) %&gt;% \n    add_edge(from = 4, to = 1,edge_aes = edge_aes(\n    label = \"6.)Access to resource data\\nis granted to the application.\",\n    fontsize = 12,\n    penwidth = 5,\n    color = \"Orange\",\n    tailport = \"s\",\n    headport = \"s\",\n    dir = \"forward\"))\n\n# Render the graph ----\nrender_graph(Diagram)\n\n\n\n\n\n\n\n\n\n\nHTTP\n\nHyper Text Transfer Protocol - HTTP serves as the underlying “protocol” or rules/procedures that Strava’s API uses. In the context of connecting to an API in R we need a library that can handle this, which is where the httr2 package comes into play. Below are some of the key concepts of connecting using HTTP\n\n\nRequest | Response model - We mentioned this above and displayed this in our flowchart:\n\nClient - App creator | request maker\nServer - Resource owner | responds to the request\n\nHTTP Methods - There are a number of methods, for our purposes the “GET” method is the only one we will use. This method is a request to retrieve data from the server.\nURIs | URLs - Uniform resource identifier also known as uniform resource locator specifies the address of the resource.\n\nBase URL - This can be found in the API documentation: \n\nData formats - The next consideration we have to make is the structure of the data that the API contains. There are two common formats; JSON (JavaScript Object Notation) and XML (extensible Markup Language). Strava’s structure is JSON so we are going to recruit the jsonlite package to help parse and map the API’s data into R objects.\n\n\n\nAPI Application\nIn this step we are going to put everything together. Using what we know about HTTP requests, OAuth2.0, and the instructions presented in Strava API V3 Documentation we should have registered our application and generated our tokens.\n\n\n\nExample Strava Creditials\n\n\n\n\nGET Request | httr2\nBelow I will be leaning on the httr2 OAuth vignette and taking notes/learning as I go. This vignette gives a much more in depth description of the OAuth framework and breaks down the httr2 connection process very succinctly.\nFor privacy I have added all keys to my .Renviron file. The keys are saved as environment variables to avoid including the creditials inside my code below I am assigning them so that I can use them in the GET request:\n\n\nCode\napp_name &lt;- Sys.getenv(\"app_name\") # Chosen by user\napp_client_id &lt;- Sys.getenv(\"app_client_id\") # this is assigned by Strava above listed as \"Client ID\" in the image\napp_secret &lt;- Sys.getenv(\"app_secret\") # This is assigned by strava as well listed as \"Client Secret\" above. You need to create an account and app in order to see this.\n\n\n\n\nEndpoint URLs\n\nLocation’s where Strava’s server/servers are hosting the data. They can be found in Strava API V3 Documentation\n\n\n\nToken URL - https://www.strava.com/oauth/token\n\n\n\n\n\nAuthorization URL - https://www.strava.com/oauth/authorize\n\n\n\n\n\nCode\ntoken_url &lt;- \"https://www.strava.com/oauth/token\"\nauth_url &lt;- \"https://www.strava.com/oauth/authorize\"\nbase_url &lt;- \"https://www.strava.com/api/v3\"\n\n\n\n\nScopes\n\n\n\nStrava Scopes - These define the applications access controls\n\n\nCreating our request & using req_dry_run() to see what the request entails:\n\n\nCode\n# Method - GET \n# Path - (/api/v3) \n# HTTP protocol version - HTTP/1.1\nreq &lt;- request(base_url)\nreq %&gt;% req_headers(Name = \"Luke Albracht\") %&gt;% req_dry_run() \n\n\nGET /api/v3 HTTP/1.1\nHost: www.strava.com\nUser-Agent: httr2/1.0.0 r-curl/5.2.1 libcurl/8.3.0\nAccept: */*\nAccept-Encoding: deflate, gzip\nName: Luke Albracht\n\n\n\n\nClient Creation\nThe httr2 OAuth vignette starts with client creation which is the first step to API connection. Using the oauth_client() function. The arguments id, token_url, secret, and name are all elements that we already accumulated. Below I have assigned these to the “strava_client” object.\n\n\nCode\n#Client creation httr2:\nstrava_client &lt;- oauth_client(\n    app_client_id,\n    secret = app_secret,\n    name = app_name,\n    token_url = token_url)\n\n\n\n\nOAuth code flow\nR continues to throw an error over the code below. I could not figure out the purpose of this step when we just ended up using req_oauth_auth_code() below in our GET request. The way that I understand this, since we already have our token this step took us to the auth_url. Seems like it might be an issue specific to the API or user error. Regardless, I am keeping this step as a part of the process.\n\n\nCode\nreq_dry_run(oauth_client_req_auth(req,strava_client))\n\n\nPOST /api/v3 HTTP/1.1\nHost: www.strava.com\nUser-Agent: httr2/1.0.0 r-curl/5.2.1 libcurl/8.3.0\nAccept: */*\nAccept-Encoding: deflate, gzip\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 71\n\nclient_id=121620&client_secret=dfd791f614b345cfeb3404b87283a4dea594032b\n\n\n\n\n\nRequest\nTo do this in httr2 I took the “req” object created above and piped it through to the family of “req_” functions that help to authenticate the request.\n\nreq_url_path_append() - adding the endpoints that I need to the base url above. The endpoints come from the Strava API which details what data each endpoint contains.\nreq_url_query() - Strava’s docs dictate that we can specify the number of pages as well as items per page. Items per page or activities per page is set to the default of 30 and pages defaults as 1. We can use the url query to pass these unique parameters into our request.\nreq_oauth_auth_code() - Finally we used this function for our authorization code flow as it covers what is needed for our application.\n\n\n\nEndpoint Params for URL query\n\n\nBasic httr2 piped based GET request:\n\n\nCode\n#GET request using everything we have covered so far:\nreq &lt;- request(base_url) %&gt;%\n  req_url_path_append(\"activities\") %&gt;%\n  req_url_query(per_page = 200, page = 1) %&gt;%\n  req_oauth_auth_code(client = strava_client,\n                      auth_url = auth_url,\n                      scope = \"activity:read_all\")\n\n#Performing request and returning the HTTP response and storing it:\nresp &lt;- req %&gt;% req_perform()\n\n#Storing the body of the response as a list of lists:\nstrava_json &lt;- resp %&gt;% resp_body_json()\n\n\n\nTo re-cap at this point I now have the follow data objects in my environment window:\n\n\nCode\n#This function was built to return the Name and Type of object in the enviroment window - I wanted a filtered list of the objects that matter and did not want to include the values/secrets:\nenv_obj_classes &lt;- function() {\n  # List the objects in your R environment\n  object_list &lt;- ls(envir = .GlobalEnv)\n  # Check if there are no objects\n  if (length(object_list) == 0) {\n    cat(\"No objects found in the environment.\\n\")\n    return(data.frame(Name = character(), Class = character(), stringsAsFactors = FALSE))\n  }\n  # Initialize an empty data frame\n  env_obj_df &lt;- data.frame(Name = character(), Class = character(), stringsAsFactors = FALSE)\n  # Loop through each object and populate the data frame\n  for (object_name in object_list) {\n    env_obj_df &lt;- rbind(\n      env_obj_df,\n      data.frame(\n        Name = object_name,\n        Class = class(get(object_name)),\n        stringsAsFactors = FALSE\n      )\n    )\n  }\n  return(env_obj_df)\n}\nenv_obj_classes() %&gt;% filter(str_detect(Name,\"strava|req|resp\")) %&gt;% tibble()"
  },
  {
    "objectID": "API Connection Walkthrough.html#part-ii-request-modification",
    "href": "API Connection Walkthrough.html#part-ii-request-modification",
    "title": "Strava API Connnection Walkthrough",
    "section": "Part II | Request Modification",
    "text": "Part II | Request Modification\nUp to this point I have covered the following:\n\nThe basics of OAuth2.0 & HTTP\nThe important parts of Strava’s API and how to use them to connect.\nThe basics of a GET request using httr2\n\nThe last part of this walk through I will cover pagination and how to modify your request in order to gather all available user data. I will be drawing from the rStrava package and watering it down to learn from them and to modify their functions for my own uses. Their package and functions take out all of the leg work that I am doing and I highly recommend using them. However, like I said in the beginning, I am using this project to develop and learn about what what is going on “under the hood”.\n\nPagination\nThis is extremely important concept if you are new to working with APIs. Pagination as it refers to APIs is the practice of breaking up the data into smaller chunks. From what I gathered, the main reason this is done is to improve performance. In my case rather than pull all 600+ activities they are broken up into chunks of 200. We can see from the Strava API that the activities endpoint has query parameters page & per_page listed above. This might be simple for most to understand, but I made the mistake of thinking of “page” as “number of pages” when above it is defined as “page number” in the sense that the pages are indexed. Each page is given an “id” 1,2,3,4….. each page can at max hold 200 items or activities. The defaults are set to pull 30 items from page 1. How did we find the 200 max? - Answer in the docs:\n\n\n\nRate Limits\nIn my case rate limits are not as big a concern as I will be the sole user of my application. It is highly unlikely I will exceed either of the limits. We can find the two types of “rate limits” that Strava maintains. The value of X-RateLimit-Limit is “200,2000” this is read as: “200 requests every 15 minutes, 2000 daily requests” we are dependent upon Strava’s documentation for this information which is referred to as the “overall rate limit”. Additionally, The value of X-ReadRateLimit-Limit is “100,1000” this is read as: “100 requests every 15 minutes, 1000 daily requests” this is referred to as “read rate limit”. Which one do we use?\nThis is another example of where we are really dependent upon “good/detailed” API documentation. The distinction between “overall rate limit” & “read rate limit” is obscure. I did not find it explicitly detailed in the documentation and I believe other users found the same issues. After this question was posted in the Strava forums the answer was published by Strava. They detail that the type of activity is a consideration in the rate limits:\n\nI know that my goal will only employ the use of the HTTP GET requests so this answers my question and I will use X-RateLimit-Limit & X-RateLimit-Usage for my project. Given the above considerations of pagination and rate limits, we know at max we can get 200 activities per page but right now the request is only pulling one page at a time. I have ~600 activities I would like to gather data on. So we have two tasks:\n\nUsing Iteration to get around the Pagination problem:\n\nreq_perform_iterative() - I am using this to perform multiple requests to the API iteratively:\n\nI pass my req request from above as one of the arguments.\nnext_req() this argument is a function that allows me to define how I want to handle the next request. In this case I am going to pass another function into this argument iterate_with_offset().\nprogress - added a progress bar because its pretty cool!\n\niterate_with_offset() - With this function I can adjust the query params from my original request. In this case I am targeting the page parameter. The key to this function is the callback function is_complete that is nested inside.\n\nis_complete - Evaluates to either TRUE or FALSE. When the resp object is returned in each iteration this function looks at the length of the body of the object. When length is == 0 that means there are no more activities to pull; is_complete would return TRUE and the resp_complete argument will stop the loop (Note: the loop is stopped on the first page to return 0 so we do receive one empty page but it will not affect the output).\n\n\nSet parameters for total requests:\n\nThis is not as serious in my case because I am not creating a package and I have no users. but regardless req_perform_iterative() -&gt; max_reqs allows me to plug in my current usage rate to be positive that I never eclipse the 15 minute request limit. Ratelimit() comes from rStrava I am including it here in the context of rate limits as an example how to handle them.\n\n\nThat’s it, below is the complete modified request. that I do not have to re-run everything I will call the basic request using R’s source function:\n\n\nCode\n#Callback function that with logical response:\nis_complete &lt;- function(resp) {\n  length(resp_body_json(resp)) == 0\n}\n\nratelimit &lt;- function(req){\n    \n    limit &lt;- as.integer(strsplit(req$headers$`x-ratelimit-limit`, \",\")[[1]])\n    usage &lt;- as.integer(strsplit(req$headers$`x-ratelimit-usage`, \",\")[[1]])\n    usage_left &lt;- limit - usage\n    \n#performs all three calculations above but returns only the last calculation when the function is used. \n    return(usage_left)\n    \n}\n\n#Below is the wrapped iterative request with all of our functions and reqs placed inside:\nresps &lt;- req_perform_iterative(\n  req,\n  next_req = iterate_with_offset(start = 1,\"page\", resp_complete = is_complete),\n  max_reqs = ratelimit(resp) %&gt;% .[1],\n  progress = TRUE\n)\n\n\n#Displaying the outcome:\nresps"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "API-Connection.github.io",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  }
]